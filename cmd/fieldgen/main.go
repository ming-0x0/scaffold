// File: cmd/columngen/main.go
package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var (
	structName  = flag.String("struct", "", "Struct name to generate fields for")
	packageName = flag.String("package", "", "Package name where struct is located")
	outputFile  = flag.String("output", "", "Output file path")
	inputFile   = flag.String("input", "", "Input file path containing the struct")
	tableName   = flag.String("table", "", "Table name in database")
)

type ColumnInfo struct {
	Name       string
	ColumnName string
}

type TemplateData struct {
	PackageName string
	StructName  string
	TableName   string
	Columns     []ColumnInfo
}

const fieldsTemplate = `// Code generated by go generate; DO NOT EDIT.
package {{ .PackageName }}

var {{ .StructName }}sTableName = "{{ .TableName }}"

// {{ .StructName }}Columns provides type-safe access to {{ .StructName }} database columns
type {{ .StructName }}Columns struct{}

func (c {{ .StructName }}Columns) TableName() string { return {{ .StructName }}sTableName }

{{ range .Columns }}func (c {{ $.StructName }}Columns) {{ .Name }}() string { return "{{ .ColumnName }}" }
{{ end }}
`

func main() {
	flag.Parse()

	if *structName == "" || *inputFile == "" || *outputFile == "" || *tableName == "" {
		log.Fatal("Usage: generate-fields -struct=StructName -input=input.go -output=output.go -table=table_name [-package=pkg]")
	}

	// Parse the input file
	columns, err := parseStructFromFile(*inputFile, *structName)
	if err != nil {
		log.Fatalf("Error parsing struct: %v", err)
	}

	// Determine package name
	pkg := *packageName
	if pkg == "" {
		pkg = getPackageFromFile(*inputFile)
	}

	// Generate output
	err = generateFieldsFile(*outputFile, TemplateData{
		PackageName: pkg,
		StructName:  *structName,
		TableName:   *tableName,
		Columns:     columns,
	})
	if err != nil {
		log.Fatalf("Error generating fields file: %v", err)
	}

	fmt.Printf("Generated %s for struct %s\n", *outputFile, *structName)
}

func parseStructFromFile(filename, structName string) ([]ColumnInfo, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var columns []ColumnInfo

	// Find the struct declaration
	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok && typeSpec.Name.Name == structName {
			if structType, ok := typeSpec.Type.(*ast.StructType); ok {
				columns = extractColumnsFromAST(structType)
			}
		}
		return true
	})

	if len(columns) == 0 {
		return nil, fmt.Errorf("struct %s not found or has no fields", structName)
	}

	return columns, nil
}

func extractColumnsFromAST(structType *ast.StructType) []ColumnInfo {
	var columns []ColumnInfo

	for _, field := range structType.Fields.List {
		// Handle embedded structs
		if len(field.Names) == 0 {
			// This is an embedded field, we'd need more complex logic to handle it
			continue
		}

		for _, name := range field.Names {
			if field.Tag != nil {
				tagValue := strings.Trim(field.Tag.Value, "`")
				columnName := extractColumnFromTag(tagValue)
				if columnName != "" {
					columns = append(columns, ColumnInfo{
						Name:       name.Name,
						ColumnName: columnName,
					})
				}
			}
		}
	}

	return columns
}

func extractColumnFromTag(tag string) string {
	// Parse struct tag like `gorm:"column:id;primaryKey;type:bigint" mapstructure:"id"`
	parts := strings.Split(tag, " ")
	for _, part := range parts {
		if strings.HasPrefix(part, `gorm:"`) {
			gormTag := strings.TrimPrefix(part, `gorm:"`)
			gormTag = strings.TrimSuffix(gormTag, `"`)

			// Extract column name from gorm tag
			tagParts := strings.Split(gormTag, ";")
			for _, tagPart := range tagParts {
				tagPart = strings.TrimSpace(tagPart)
				if strings.HasPrefix(tagPart, "column:") {
					return strings.TrimPrefix(tagPart, "column:")
				}
			}
		}
	}
	return ""
}

func getPackageFromFile(filename string) string {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.PackageClauseOnly)
	if err != nil {
		return "main"
	}
	return node.Name.Name
}

func generateFieldsFile(outputPath string, data TemplateData) error {
	// Create output directory if it doesn't exist
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	// Parse template
	tmpl, err := template.New("columns").Parse(fieldsTemplate)
	if err != nil {
		return err
	}

	// Create output file
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Execute template
	return tmpl.Execute(file, data)
}
