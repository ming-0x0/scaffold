// File: cmd/generate-fields/main.go
package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var (
	structName  = flag.String("struct", "", "Struct name to generate fields for")
	packageName = flag.String("package", "", "Package name where struct is located")
	outputFile  = flag.String("output", "", "Output file path")
	inputFile   = flag.String("input", "", "Input file path containing the struct")
)

type FieldInfo struct {
	Name       string
	ColumnName string
}

type TemplateData struct {
	PackageName string
	StructName  string
	Fields      []FieldInfo
}

const fieldsTemplate = `// Code generated by go generate; DO NOT EDIT.
package {{ .PackageName }}

// {{ .StructName }}Fields provides type-safe access to {{ .StructName }} database columns
type {{ .StructName }}Fields struct{}

{{ range .Fields }}func (f {{ $.StructName }}Fields) {{ .Name }}() ColumnField { return ColumnField{name: "{{ .ColumnName }}"} }
{{ end }}
// New{{ .StructName }}Repository creates a new repository with type-safe fields
func New{{ .StructName }}Repository(db *gorm.DB, logger *logrus.Logger) *Repository[{{ .StructName }}, {{ .StructName }}Fields] {
	return New[{{ .StructName }}, {{ .StructName }}Fields](db, logger, {{ .StructName }}Fields{})
}
`

func main() {
	flag.Parse()

	if *structName == "" || *inputFile == "" || *outputFile == "" {
		log.Fatal("Usage: generate-fields -struct=StructName -input=input.go -output=output.go [-package=pkg]")
	}

	// Parse the input file
	fields, err := parseStructFromFile(*inputFile, *structName)
	if err != nil {
		log.Fatalf("Error parsing struct: %v", err)
	}

	// Determine package name
	pkg := *packageName
	if pkg == "" {
		pkg = getPackageFromFile(*inputFile)
	}

	// Generate output
	err = generateFieldsFile(*outputFile, TemplateData{
		PackageName: pkg,
		StructName:  *structName,
		Fields:      fields,
	})
	if err != nil {
		log.Fatalf("Error generating fields file: %v", err)
	}

	fmt.Printf("Generated %s for struct %s\n", *outputFile, *structName)
}

func parseStructFromFile(filename, structName string) ([]FieldInfo, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var fields []FieldInfo

	// Find the struct declaration
	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok && typeSpec.Name.Name == structName {
			if structType, ok := typeSpec.Type.(*ast.StructType); ok {
				fields = extractFieldsFromAST(structType)
			}
		}
		return true
	})

	if len(fields) == 0 {
		return nil, fmt.Errorf("struct %s not found or has no fields", structName)
	}

	return fields, nil
}

func extractFieldsFromAST(structType *ast.StructType) []FieldInfo {
	var fields []FieldInfo

	for _, field := range structType.Fields.List {
		// Handle embedded structs
		if len(field.Names) == 0 {
			// This is an embedded field, we'd need more complex logic to handle it
			continue
		}

		for _, name := range field.Names {
			if field.Tag != nil {
				tagValue := strings.Trim(field.Tag.Value, "`")
				columnName := extractColumnFromTag(tagValue)
				if columnName != "" {
					fields = append(fields, FieldInfo{
						Name:       name.Name,
						ColumnName: columnName,
					})
				}
			}
		}
	}

	return fields
}

func extractColumnFromTag(tag string) string {
	// Parse struct tag like `gorm:"column:id;primaryKey;type:bigint" mapstructure:"id"`
	parts := strings.SplitSeq(tag, " ")
	for part := range parts {
		if strings.HasPrefix(part, `gorm:"`) {
			gormTag := strings.Trim(part, `gorm:"`)
			gormTag = strings.TrimSuffix(gormTag, `"`)

			// Extract column name from gorm tag
			tagParts := strings.SplitSeq(gormTag, ";")
			for tagPart := range tagParts {
				tagPart = strings.TrimSpace(tagPart)
				if strings.HasPrefix(tagPart, "column:") {
					return strings.TrimPrefix(tagPart, "column:")
				}
			}
		}
	}
	return ""
}

func getPackageFromFile(filename string) string {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.PackageClauseOnly)
	if err != nil {
		return "main"
	}
	return node.Name.Name
}

func generateFieldsFile(outputPath string, data TemplateData) error {
	// Create output directory if it doesn't exist
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	// Parse template
	tmpl, err := template.New("fields").Parse(fieldsTemplate)
	if err != nil {
		return err
	}

	// Create output file
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Execute template
	return tmpl.Execute(file, data)
}
